<jqa:jqassistant-rules xmlns:jqa="http://www.buschmais.com/jqassistant/core/rule/schema/v1.4">

    <group id="java-ddd:Default">
        <includeConcept refId="java-ddd:*" severity="info"/>
        <includeConstraint refId="java-ddd:*"/>
    </group>

    <concept id="java-ddd:PrepareBoundedContext">
        <description>Creates a bounded context node per defined bounded context (identified by name) based on org.jqassistant.contrib.plugin.ddd.annotation.DDD$BoundedContext.</description>
        <cypher><![CDATA[
            MATCH
             ()-[:ANNOTATED_BY]->(annotation)-[:OF_TYPE]->(annotationType:Type),
             (annotation)-[:HAS]->(value:Value)
            WHERE
              annotationType.fqn = "org.jqassistant.contrib.plugin.ddd.annotation.DDD$BoundedContext" AND
              value.name = "name"
            MERGE
              (boundedContext:BoundedContext{name: value.value})
            RETURN
              boundedContext
        ]]></cypher>
    </concept>

    <concept id="java-ddd:BoundedContextPackage">
        <requiresConcept refId="java-ddd:PrepareBoundedContext"/>
        <description>Maps all Java types which are located in a package annotated by
            org.jqassistant.contrib.plugin.ddd.annotation.DDD.BoundedContext to the corresponding BoundedContext node.</description>
        <cypher><![CDATA[
            MATCH
              (bCPackage:Package)-[:CONTAINS]->(packageInfo:Type)-[:ANNOTATED_BY]->(a)-[:OF_TYPE]->(annotation:Type),
              (a)-[:HAS]->(name:Value)
            WHERE
              annotation.fqn IN [
                "org.jqassistant.contrib.plugin.ddd.annotation.DDD$BoundedContext"
              ]
              AND name.name = "name"
              AND packageInfo.sourceFileName = "package-info.java"
            WITH
              bCPackage, name.value AS bCName
            MATCH
              (boundedContext:BoundedContext{name: bCName})
            WITH
              bCPackage, boundedContext
            MATCH
              (bCPackage)-[:CONTAINS*]->(contextType:Type)
            MERGE
              (boundedContext)-[c:CONTAINS]->(contextType)
            RETURN
              boundedContext.name, contextType.fqn
        ]]></cypher>
    </concept>

    <concept id="java-ddd:BoundedContextType">
        <requiresConcept refId="java-ddd:PrepareBoundedContext"/>
        <description>Maps all Java types which are annotated by
            org.jqassistant.contrib.plugin.ddd.annotation.DDD.BoundedContext to the corresponding BoundedContext node.</description>
        <cypher><![CDATA[
            MATCH
              (contextType:Type)-[:ANNOTATED_BY]->(a)-[:OF_TYPE]->(annotation:Type),
              (a)-[:HAS]->(name:Value)
            WHERE
              annotation.fqn IN [
                "org.jqassistant.contrib.plugin.ddd.annotation.DDD$BoundedContext"
              ]
              AND name.name = "name"
            WITH
              contextType, name.value AS bCName
            MATCH
              (boundedContext:BoundedContext{name: bCName})
            WITH
              contextType, boundedContext
            MERGE
              (boundedContext)-[:CONTAINS]->(contextType)
            RETURN
              boundedContext.name, contextType.fqn
        ]]></cypher>
    </concept>

    <concept id="java-ddd:BoundedContextDependency">
        <requiresConcept refId="java-ddd:BoundedContextPackage"/>
        <requiresConcept refId="java-ddd:BoundedContextType"/>
        <description>Propagates the dependencies between Types of different Bounded Contexts to the level of Bounded Contexts including an aggregated weight.</description>
        <cypher><![CDATA[
            MATCH
              (boundedContext1:BoundedContext)-[:CONTAINS]->(contextType1:Type),
              (boundedContext2:BoundedContext)-[:CONTAINS]->(contextType2:Type),
              (contextType1)-[d:DEPENDS_ON]->(contextType2)
            WITH
              boundedContext1, boundedContext2, sum(d.weight) AS totalWeight
            MERGE
              (boundedContext1)-[d:DEPENDS_ON{weight: totalWeight}]->(boundedContext2)
            RETURN
              boundedContext1.name AS Source, sum(d.weight) AS Weight, boundedContext2.name AS Target
        ]]></cypher>
        <report type="d3js">
            <property name="diagram-type">chord</property>
            <property name="data-format">csv</property>
        </report>

    </concept>

    <concept id="java-ddd:EntityPackage">
        <description>Labels all Java types which are located in package annotated by org.jqassistant.contrib.plugin.ddd.annotation.DDD.Entity as :DDD:Entity.</description>
        <cypher><![CDATA[
	    MATCH
              (entityPackage:Package)-[:CONTAINS]->(packageInfo:Type)-[:ANNOTATED_BY]->(a)-[:OF_TYPE]->(annotation:Type)
            WHERE
              annotation.fqn IN [
                "org.jqassistant.contrib.plugin.ddd.annotation.DDD$Entity"
              ]
              AND packageInfo.sourceFileName = "package-info.java"
            WITH
              entityPackage
            MATCH
              (entityPackage)-[:CONTAINS*]->(entity:Type)
	    SET
  	      entity:DDD:Entity
            RETURN
              entity AS Entity
        ]]></cypher>
    </concept>

    <concept id="java-ddd:EntityType">
        <description>Labels all Java types which are annotated by org.jqassistant.contrib.plugin.ddd.annotation.DDD.Entity or javax.persistence.Entity as :DDD:Entity.</description>
        <cypher><![CDATA[
	    MATCH
              (entity:Type)-[:ANNOTATED_BY]->()-[:OF_TYPE]->(annotation:Type)
            WHERE
              annotation.fqn IN [
                "org.jqassistant.contrib.plugin.ddd.annotation.DDD$Entity",
 		        "javax.persistence.Entity"
              ]
	    SET
  	      entity:DDD:Entity
            RETURN
              entity AS Entity
        ]]></cypher>
    </concept>

    <concept id="java-ddd:AggregatePackage">
        <description>Labels all Java types which are located in package annotated by org.jqassistant.contrib.plugin.ddd.annotation.DDD.Aggregate as :DDD:Aggregate.</description>
        <cypher><![CDATA[
	    MATCH
              (aggregatePackage:Package)-[:CONTAINS]->(packageInfo:Type)-[:ANNOTATED_BY]->(a)-[:OF_TYPE]->(annotation:Type)
            WHERE
              annotation.fqn IN [
                "org.jqassistant.contrib.plugin.ddd.annotation.DDD$Aggregate"
              ]
              AND packageInfo.sourceFileName = "package-info.java"
            WITH
              aggregatePackage
            MATCH
              (aggregatePackage)-[:CONTAINS*]->(aggregate:Type)
	    SET
  	      aggregate:DDD:Aggregate
            RETURN
              aggregate AS Aggregate
        ]]></cypher>
    </concept>

    <concept id="java-ddd:AggregateType">
        <description>Labels all Java types which are annotated by
            org.jqassistant.contrib.plugin.ddd.annotation.DDD.Aggregate as :DDD:Aggregate.</description>
        <cypher><![CDATA[
            MATCH
              (aggregate:Type)-[:ANNOTATED_BY]->()-[:OF_TYPE]->(annotation:Type)
            WHERE
              annotation.fqn IN [
                "org.jqassistant.contrib.plugin.ddd.annotation.DDD$Aggregate"
              ]
            SET
              aggregate:DDD:Aggregate
            RETURN
              aggregate AS Aggregate
        ]]></cypher>
    </concept>

    <concept id="java-ddd:ValueObjectPackage">
        <description>Labels all Java types which are located in a package annotated by org.jqassistant.contrib.plugin.ddd.annotation.DDD.ValueObject as :DDD:ValueObject.</description>
        <cypher><![CDATA[
	    MATCH
              (valueObjectPackage:Package)-[:CONTAINS]->(packageInfo:Type)-[:ANNOTATED_BY]->(a)-[:OF_TYPE]->(annotation:Type)
            WHERE
              annotation.fqn IN [
                "org.jqassistant.contrib.plugin.ddd.annotation.DDD$ValueObject"
              ]
              AND packageInfo.sourceFileName = "package-info.java"
            WITH
              valueObjectPackage
            MATCH
              (valueObjectPackage)-[:CONTAINS*]->(valueObject:Type)
	    SET
  	      valueObject:DDD:ValueObject
            RETURN
              valueObject AS ValueObject
        ]]></cypher>
    </concept>

    <concept id="java-ddd:ValueObjectType">
        <description>Labels all Java types which are annotated by javax.persistence.Embeddable or
            org.jqassistant.contrib.plugin.ddd.annotation.DDD.ValueObject as :DDD:ValueObject.</description>
        <cypher><![CDATA[
            MATCH
              (valueObject:Type)-[:ANNOTATED_BY]->()-[:OF_TYPE]->(annotation:Type)
            WHERE
              annotation.fqn IN [
                "javax.persistence.Embeddable",
                "org.jqassistant.contrib.plugin.ddd.annotation.DDD$ValueObject"
              ]
            SET
              valueObject:DDD:ValueObject
            RETURN
              valueObject AS ValueObject
        ]]></cypher>
    </concept>

    <concept id="java-ddd:ServicePackage">
        <description>Labels all Java types which are located in a package annotated by org.jqassistant.contrib.plugin.ddd.annotation.DDD.Service as :DDD:Service.</description>
        <cypher><![CDATA[
	    MATCH
              (servicePackage:Package)-[:CONTAINS]->(packageInfo:Type)-[:ANNOTATED_BY]->(a)-[:OF_TYPE]->(annotation:Type)
            WHERE
              annotation.fqn IN [
                "org.jqassistant.contrib.plugin.ddd.annotation.DDD$Service"
              ]
              AND packageInfo.sourceFileName = "package-info.java"
            WITH
              servicePackage
            MATCH
              (servicePackage)-[:CONTAINS*]->(service:Type)
	    SET
  	      service:DDD:Service
            RETURN
              service AS Service
        ]]></cypher>
    </concept>

    <concept id="java-ddd:ServiceType">
        <description>Labels all Java types which are annotated by
            org.jqassistant.contrib.plugin.ddd.annotation.DDD.Service as :DDD:Service.</description>
        <cypher><![CDATA[
            MATCH
              (service:Type)-[:ANNOTATED_BY]->()-[:OF_TYPE]->(annotation:Type)
            WHERE
              annotation.fqn IN [
                "org.jqassistant.contrib.plugin.ddd.annotation.DDD$Service"
              ]
            SET
              service:DDD:Service
            RETURN
              service AS Service
        ]]></cypher>
    </concept>

    <concept id="java-ddd:RepositoryPackage">
        <description>Labels all Java types which are located in a package annotated by org.jqassistant.contrib.plugin.ddd.annotation.DDD.Repository as :DDD:Repository.</description>
        <cypher><![CDATA[
	    MATCH
              (repositoryPackage:Package)-[:CONTAINS]->(packageInfo:Type)-[:ANNOTATED_BY]->(a)-[:OF_TYPE]->(annotation:Type)
            WHERE
              annotation.fqn IN [
                "org.jqassistant.contrib.plugin.ddd.annotation.DDD$Repository"
              ]
              AND packageInfo.sourceFileName = "package-info.java"
            WITH
              repositoryPackage
            MATCH
              (repositoryPackage)-[:CONTAINS*]->(repository:Type)
	    SET
  	      repository:DDD:Repository
            RETURN
              repository AS Repository
        ]]></cypher>
    </concept>

    <concept id="java-ddd:RepositoryType">
        <description>Labels all Java types which are annotated by
            org.jqassistant.contrib.plugin.ddd.annotation.DDD.Repository as :DDD:Repository.</description>
        <cypher><![CDATA[
            MATCH
              (repository:Type)-[:ANNOTATED_BY]->()-[:OF_TYPE]->(annotation:Type)
            WHERE
              annotation.fqn IN [
                "org.jqassistant.contrib.plugin.ddd.annotation.DDD$Repository"
              ]
            SET
              repository:DDD:Repository
            RETURN
              repository AS Repository
        ]]></cypher>
    </concept>

    <concept id="java-ddd:DomainEventPackage">
        <description>Labels all Java types which are located in a package annotated by org.jqassistant.contrib.plugin.ddd.annotation.DDD.DomainEvent as :DDD:DomainEvent.</description>
        <cypher><![CDATA[
	    MATCH
              (domainEventPackage:Package)-[:CONTAINS]->(packageInfo:Type)-[:ANNOTATED_BY]->(a)-[:OF_TYPE]->(annotation:Type)
            WHERE
              annotation.fqn IN [
                "org.jqassistant.contrib.plugin.ddd.annotation.DDD$DomainEvent"
              ]
              AND packageInfo.sourceFileName = "package-info.java"
            WITH
              domainEventPackage
            MATCH
              (domainEventPackage)-[:CONTAINS*]->(domainEvent:Type)
	    SET
  	      domainEvent:DDD:DomainEvent
            RETURN
              domainEvent AS DomainEvent
        ]]></cypher>
    </concept>

    <concept id="java-ddd:DomainEventType">
        <description>Labels all Java types which are annotated by
            org.jqassistant.contrib.plugin.ddd.annotation.DDD.DomainEvent as :DDD:DomainEvent.</description>
        <cypher><![CDATA[
            MATCH
              (domainEvent:Type)-[:ANNOTATED_BY]->()-[:OF_TYPE]->(annotation:Type)
            WHERE
              annotation.fqn IN [
                "org.jqassistant.contrib.plugin.ddd.annotation.DDD$DomainEvent"
              ]
            SET
              domainEvent:DDD:DomainEvent
            RETURN
              domainEvent AS DomainEvent
        ]]></cypher>
    </concept>

    <concept id="java-ddd:FactoryPackage">
        <description>Labels all Java types which are located in a package annotated by org.jqassistant.contrib.plugin.ddd.annotation.DDD.Factory as :DDD:Factory.</description>
        <cypher><![CDATA[
	    MATCH
              (factoryPackage:Package)-[:CONTAINS]->(packageInfo:Type)-[:ANNOTATED_BY]->(a)-[:OF_TYPE]->(annotation:Type)
            WHERE
              annotation.fqn IN [
                "org.jqassistant.contrib.plugin.ddd.annotation.DDD$Factory"
              ]
              AND packageInfo.sourceFileName = "package-info.java"
            WITH
              factoryPackage
            MATCH
              (factoryPackage)-[:CONTAINS*]->(factory:Type)
	    SET
  	      factory:DDD:Factory
        RETURN
          factory AS Factory
        ]]></cypher>
    </concept>

    <concept id="java-ddd:FactoryType">
        <description>Labels all Java types which are annotated by
            org.jqassistant.contrib.plugin.ddd.annotation.DDD.Factory as :DDD:Factory.</description>
        <cypher><![CDATA[
            MATCH
              (factory:Type)-[:ANNOTATED_BY]->()-[:OF_TYPE]->(annotation:Type)
            WHERE
              annotation.fqn IN [
                "org.jqassistant.contrib.plugin.ddd.annotation.DDD$Factory"
              ]
            SET
              factory:DDD:Factory
            RETURN
              factory AS Factory
        ]]></cypher>
    </concept>

    <concept id="java-ddd:LayerPackage">
        <description>Labels all Java types which are annotated by
            org.jqassistant.contrib.plugin.ddd.annotation.DDD.Layer.X as :DDD:Layer:X.</description>
        <cypher><![CDATA[
            MATCH
              (layerPackage:Package)-[:CONTAINS]->(packageInfo:Type)-[:ANNOTATED_BY]->(a)-[:OF_TYPE]->(annotation:Type)
            WHERE
              annotation.fqn STARTS WITH "org.jqassistant.contrib.plugin.ddd.annotation.DDD$Layer"
              AND packageInfo.sourceFileName = "package-info.java"
            WITH
              layerPackage, annotation
            MATCH
              (layerPackage)-[:CONTAINS*]->(layer:Type)
            WITH
              layer AS layer, annotation.name AS layerName
            FOREACH (type in CASE WHEN layerName =  "DDD$Layer$InterfaceLayer" THEN [1] ELSE [] END | SET layer:DDD:Layer:InterfaceLayer)
            FOREACH (type in CASE WHEN layerName =  "DDD$Layer$ApplicationLayer" THEN [1] ELSE [] END | SET layer:DDD:Layer:ApplicationLayer)
            FOREACH (type in CASE WHEN layerName =  "DDD$Layer$DomainLayer" THEN [1] ELSE [] END | SET layer:DDD:Layer:DomainLayer)
            FOREACH (type in CASE WHEN layerName =  "DDD$Layer$InfrastructureLayer" THEN [1] ELSE [] END | SET layer:DDD:Layer:InfrastructureLayer)
            RETURN
              layer AS Type, layerName AS Layer
        ]]></cypher>
    </concept>

    <concept id="java-ddd:LayerType">
        <description>Labels all Java types which are annotated by
            org.jqassistant.contrib.plugin.ddd.annotation.DDD.Layer.X as :DDD:Layer:X.</description>
        <cypher><![CDATA[
            MATCH
              (layer:Type)-[:ANNOTATED_BY]->()-[:OF_TYPE]->(annotation:Type)
            WHERE
              annotation.fqn STARTS WITH "org.jqassistant.contrib.plugin.ddd.annotation.DDD$Layer$"
            WITH
              layer AS layer, annotation.name AS layerName
            FOREACH (type in CASE WHEN layerName =  "DDD$Layer$InterfaceLayer" THEN [1] ELSE [] END | SET layer:DDD:Layer:InterfaceLayer)
            FOREACH (type in CASE WHEN layerName =  "DDD$Layer$ApplicationLayer" THEN [1] ELSE [] END | SET layer:DDD:Layer:ApplicationLayer)
            FOREACH (type in CASE WHEN layerName =  "DDD$Layer$DomainLayer" THEN [1] ELSE [] END | SET layer:DDD:Layer:DomainLayer)
            FOREACH (type in CASE WHEN layerName =  "DDD$Layer$InfrastructureLayer" THEN [1] ELSE [] END | SET layer:DDD:Layer:InfrastructureLayer)
            RETURN
              layer AS Type, layerName AS Layer
        ]]></cypher>
    </concept>

    <constraint id="java-ddd:TransactionsByApplicationLayer">
        <requiresConcept refId="java-ddd:LayerType"/>
        <requiresConcept refId="java-ddd:LayerPackage"/>
        <description>Checks that only application layer classes span transactions.</description>
        <cypher><![CDATA[
            MATCH
              (nonAppType:Type:DDD:Layer)-[:ANNOTATED_BY]->()-[:OF_TYPE]->(annotation:Type)
            WHERE
              annotation.fqn IN [
                "javax.transaction.Transactional",
                "org.springframework.transaction.annotation.Transactional",
                "javax.ejb.TransactionAttribute"
              ]
              AND (nonAppType:Layer:InterfaceLayer OR nonAppType:Layer:DomainLayer OR nonAppType:InfrastructureLayer)
            RETURN
              nonAppType.fqn AS IllegalTransactionSpanning
        ]]></cypher>
    </constraint>

    <constraint id="java-ddd:EntityAccessedByRepository">
        <requiresConcept refId="java-ddd:RepositoryType"/>
        <requiresConcept refId="java-ddd:RepositoryPackage"/>
        <requiresConcept refId="java-ddd:EntityType"/>
        <requiresConcept refId="java-ddd:EntityPackage"/>
        <description>Checks that only aggregates and not entities are accessed by repositories (both as parameters and return values).</description>
        <cypher><![CDATA[
            MATCH
              (repository:Type:DDD:Repository)-[:DEPENDS_ON]->(entity:Type:DDD:Entity)
            WHERE
              NOT entity:Aggregate
            RETURN
              entity.fqn AS NonAggregateType
        ]]></cypher>
    </constraint>

    <constraint id="java-ddd:LayerDependencies">
        <requiresConcept refId="java-ddd:LayerType"/>
        <requiresConcept refId="java-ddd:LayerPackage"/>
        <description>Checks that only dependencies between layers exist that are allowed by DDD.</description>
        <cypher><![CDATA[
            MATCH
              (source:Type:DDD:Layer)-[:DEPENDS_ON]->(target:Type:DDD:Layer)
            WHERE
              source <> target AND
              (
                source:InterfaceLayer AND target:InfrastructureLayer OR
                source:ApplicationLayer AND target:InfrastructureLayer OR
                source:ApplicationLayer AND target:InterfaceLayer OR
                source:DomainLayer AND target:InfrastructureLayer OR
                source:DomainLayer AND target:InterfaceLayer OR
                source:DomainLayer AND target:ApplicationLayer
              )
            RETURN
              source.fqn AS Source, target.fqn AS IllegalDependency
        ]]></cypher>
    </constraint>

    <constraint id="java-ddd:TypeInMultipleBoundedContexts">
        <requiresConcept refId="java-ddd:BoundedContextType"/>
        <requiresConcept refId="java-ddd:BoundedContextPackage"/>
        <description>Checks that a single DDD type is only part of one bounded context.</description>
        <cypher><![CDATA[
          MATCH
            (boundedContext:BoundedContext)-[:CONTAINS]->(bCType:Type)
          WITH
            bCType, collect(boundedContext.name) AS boundedContexts
          WHERE
            size(boundedContexts) > 1
          RETURN
            bCType AS Type, boundedContexts AS AssignedBoundedContext
        ]]></cypher>
    </constraint>

</jqa:jqassistant-rules>
